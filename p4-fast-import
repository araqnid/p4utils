#!/usr/bin/perl -w

require 5;
use strict;
use warnings;
use utf8;
use Getopt::Std;
use IO::Pipe;
use IO::File;
use IO::Wrap;
use Git;
use Error qw(:try);
use Data::Dumper;
use Cwd qw(abs_path);
use PerforceLink qw(:p4);
# p4 help filetypes
use constant FILETYPE_ALIASES => {
    "ctext" => ["text", "C"],
    "cxtext" => ["text", "Cx"],
    "ktext" => ["text", "k"],
    "kxtext" => ["text", "kx"],
    "ltext" => ["text", "F"],
    "tempobj" => ["binary", "Sw"],
    "ubinary" => ["binary", "F"],
    "uresource" => ["resource", "F"],
    "uxbinary" => ["binary", "Fx"],
    "xbinary" => ["binary", "x"],
    "xltext" => ["text", "Fx"],
    "xtempobj" => ["binary", "Swx"],
    "xtext" => ["text", "x"],
    "xunicode" => ["unicode", "x"],
    "xutf16" => ["utf16", "x"],
};

sub get_p4user($) {
    my $userid = shift;
    our %usertab;
    if (!%usertab) {
	for (p4_recv("users")) {
	    $usertab{$_->{User}} = $_;
	}
    }
    return $usertab{$userid} || { User => $userid, Email => "$userid\@defunct.example.com", FullName => "$userid" };
}

sub decode_p4_filetype($) {
    my $filetype = shift;
    my $aliased = FILETYPE_ALIASES->{$filetype};
    return @$aliased if ($aliased);
    my($basetype, $mods) = split(/\+/, $filetype, 2);
    $mods ||= '';
    return ($basetype, $mods);
}

sub validate_p4_base($) {
    my $dir = shift;
    p4_recv("dirs", $dir) or die "Perforce base directory does not exist: $dir\n";
}

sub fetch_p4_changes($$$$$$$$) {
    my($slavepipe, $p4base, $previous_tip_change, $p4_remote_name, $p4_remote_branch, $max_changes, $checkpoint_interval, $tag_changelists) = @_;
    my $last_checkpoint = [time, 0, 0];
    my $data_sent = 0;
    my $chgcounter = 0;

    $slavepipe->print("progress $p4base/...".($previous_tip_change ? " since \@$previous_tip_change":"")."\n");

    my @p4changes;
    for my $p4change (p4_recv("changes", "-l", "-t", "$p4base/...".($previous_tip_change ? join("", '@', $previous_tip_change+1, ",#head") : ""))) {
	my $p4changedesc = [split(/\n/, $p4change->{desc})]->[0] || '';
	my $p4user_info = get_p4user($p4change->{user});
	unshift @p4changes, { user => $p4user_info, id => $p4change->{change}, subject => $p4changedesc, desc => $p4change->{desc}, time => $p4change->{time} };
    }

    my $last_change;
    for my $p4change (@p4changes) {
	$slavepipe->print("progress $p4change->{id} - $p4change->{user}->{User} - $p4change->{subject}\n");
	my $raw_changeinfo = p4_recv("describe", "-s", $p4change->{id});
	my $commit_text = $p4change->{desc};

	$slavepipe->print("commit refs/remotes/$p4_remote_name/$p4_remote_branch\n");
	$slavepipe->print("mark :$p4change->{id}\n");
	$slavepipe->print("committer $p4change->{user}->{FullName} <$p4change->{user}->{Email}> $p4change->{time} +0000\n");
	$slavepipe->print("data ".length($commit_text)."\n");
	$slavepipe->print("$commit_text\n");
	if (!$last_change && $previous_tip_change) {
	    $slavepipe->print("from refs/remotes/$p4_remote_name/$p4_remote_branch^0\n");
	}

	for (my $i = 0; exists $raw_changeinfo->{"action$i"}; $i++) {
	    my($action, $file, $type, $rev) = map { $raw_changeinfo->{$_} } ("action$i", "depotFile$i", "type$i", "rev$i" );
	    my($basetype, $typemods) = decode_p4_filetype($type);
	    $slavepipe->print("# $action $file#$rev\n");
	    next if (length($file) < length($p4base) || substr($file, 0, length($p4base)) ne $p4base);
	    my $git_path = substr($file, length($p4base)+1);
	    if ($action eq 'delete' || $action eq 'purge') {
		$slavepipe->print("D $git_path\n");
	    }
	    else {
		my $tmpfilename = ($ENV{TMPDIR} || "/tmp")."/p4fi".sprintf("%x%x%x", rand() * 0x10000, $$, time);
		sysopen(DATA, $tmpfilename, O_WRONLY|O_EXCL|O_CREAT, 0600) or die "Unable to write $tmpfilename: $!\n";
		my $filterpipe = ($basetype eq 'text' && $typemods =~ /k/) && IO::Pipe->new;
		my $printpid = fork;
		die "Cannot fork: $!\n" unless (defined $printpid);
		if ($printpid == 0) {
		    if ($filterpipe) {
			$filterpipe->writer;
			open(STDOUT, ">&=".$filterpipe->fileno) or die "Unable to redirect stdout: $!\n";
		    }
		    else {
			open(STDOUT, ">&=".(fileno DATA)) or die "Unable to redirect stdout: $!\n";
		    }
		    exec "p4", "print", "-q", "$file#$rev" or die "Unable to exec p4 print: $!\n";
		}
		if ($filterpipe) {
		    my $restricted = $typemods =~ /k(o?)/ && $1 eq 'o';
		    $filterpipe->reader;
		    my $changes = 0;
		    my $lines = 0;
		    while (<$filterpipe>) {
			++$lines;
			s{\$Id: \S+\#\d+ \$}{\$Id\$}g && ++$changes;
			s{\$Header: [^\$]+ \$}{\$Header\$}g && ++$changes;
			s{\$(Author|Date|DateTime|Change|File|Revision): [^\$]+ \$}{\$$1\$}g && ++$changes
			    unless ($restricted);
			print DATA;
		    }
		    $filterpipe->close;
		}
		waitpid($printpid, 0) or die "Unable to wait for $printpid: $!\n";
		my $printstatus = $?;
		$printstatus == 0 or die "p4 print exited: ".PerforceLink::decode_exitstatus($printstatus)."\n";
		close(DATA);

		my $file_size = -s $tmpfilename;
		my $mode = ($typemods =~ /x/) ? "100755" : "100644";
		$slavepipe->print("M $mode inline $git_path\n");
		$slavepipe->print("data $file_size\n");
		open(DATA, $tmpfilename) or die "Unable to read temporary file: $!\n";
		my $remain = $file_size;
		my $got = 0;
		my $buf;
		while (($got = sysread(DATA, $buf, 16384)) > 0) {
		    $remain -= $got;
		    $slavepipe->print($buf);
		}
		if ($remain != 0) {
		    die "Lost $remain bytes when reading temp file\n";
		}
		unlink $tmpfilename;
		$slavepipe->print("\n");
		$data_sent += $file_size;
	    }
	}

	if ($tag_changelists) {
	    $slavepipe->print("reset refs/tags/$p4_remote_name/$p4change->{id}\n");
	    $slavepipe->print("from :$p4change->{id}\n");
	    $slavepipe->print("\n");
	}

	++$chgcounter;

	my %need_checkpoint;
	$need_checkpoint{time} = 1 if ($checkpoint_interval->{time} && time > ($last_checkpoint->[0]+$checkpoint_interval->{time}));
	$need_checkpoint{commits} = 1 if ($checkpoint_interval->{commits} && $chgcounter > ($last_checkpoint->[1]+$checkpoint_interval->{commits}));
	$need_checkpoint{bytes} = 1 if ($checkpoint_interval->{bytes} && $data_sent > ($last_checkpoint->[2]+$checkpoint_interval->{bytes}));

	if (keys %need_checkpoint) {
	    $slavepipe->print("checkpoint\n");
	    $slavepipe->print("progress Checkpoint: ".join(", ", sort keys %need_checkpoint).": $chgcounter/".scalar @p4changes."\n");
	    $last_checkpoint = [time, $chgcounter, $data_sent];
	}

	$last_change = $p4change;
	last if ($max_changes > 0 && $chgcounter >= $max_changes);
    }

    $slavepipe->print("progress All done; $chgcounter changes, $data_sent bytes\n");

    return $last_change && $last_change->{id};
}

sub convertpath($$$) {
    my $dirname = shift;
    my $input_pattern = shift;
    my $output_pattern = shift;

    # Trivial cases
    return $output_pattern if ($input_pattern !~ /\*/ && $input_pattern eq $dirname);
    return $dirname if ($input_pattern eq $output_pattern);

    my $input_re = $input_pattern;
    $input_re =~ s{\*}{(.*)};

    my $output_string = $output_pattern;
    my $index = 1;
    $output_string =~ s{\*}{"\$".($index++)}ge;

    eval "\$dirname =~ s{$input_re}{$output_string}";

    return $dirname;
}

sub get_config_optional($$) {
    my $git_repo = shift;
    my $key = shift;

    try {
	return $git_repo->command_oneline("config", "--get", $key);
    } catch Git::Error::Command with {
	return undef;
    }
}

sub fetch_last_changelist($$$) {
    my $git_repo = shift;
    my $p4_remote_name = shift;
    my $branch = shift;

    return get_config_optional($git_repo, "branch.refs/remotes/$p4_remote_name/$branch.changelist");
}

sub get_current_branch($) {
    my $git_repo = shift;
    try {
	my $head_ref = $git_repo->command_oneline("symbolic-ref", "HEAD");
	return $head_ref =~ m|^refs/heads/(.+)| && $1;
    } catch Git::Error::Command with {
	# e.g. detached head
	return undef;
    }
}

my %globalopts;
getopts('dr:', \%globalopts) && @ARGV >= 1 or die "Syntax: $0 [-d] subcommand [args...]\n";
$PerforceLink::DEBUG = 1 if ($globalopts{d});
my $remotename = $globalopts{r} || 'p4';
my $subcommand = shift;

if ($subcommand eq 'clone') {
    my %opts;
    getopts("o:d:m:nC:B:T:t", \%opts) && @ARGV >= 1 or die "Syntax: $0 clone [-o fast-import-dump|-d git-repo] [-n] [-m max-changes] [-t] [-C commits-chkpt-interval] [-B bytes-chkpt-interval] [-T time-chkpt-interval] perforce-root-dir [branchspec...]\n";

    my $p4base = shift;
    $p4base =~ s{/(\.\.\.)?$}{};
    validate_p4_base($p4base);

    my $git_repo_dir = $opts{d};
    my $git_repo;
    if (!$git_repo_dir) {
	($git_repo_dir = $p4base) =~ s|.*/||;
	$git_repo_dir .= ".git" if ($opts{n});
	$git_repo_dir = abs_path($git_repo_dir);
    }
    if (!$opts{o}) {
	die "GIT repo directory must be given if -o is not given\n" unless ($git_repo_dir);
	if (! -d $git_repo_dir) {
	    mkdir $git_repo_dir, 0775 or die "Unable to create $git_repo_dir: $!\n";
	    my $initpid = fork;
	    die "Cannot fork: $!\n" unless (defined($initpid));
	    if ($initpid == 0) {
		chdir $git_repo_dir or die "Unable to chdir to $git_repo_dir: $!\n";
		if ($opts{n}) {
		    exec("git", "init", "--bare") or die "Unable to exec git: $!\n";
		}
		else {
		    exec("git", "init") or die "Unable to exec git: $!\n";
		}
	    }
	    waitpid($initpid, 0) or die "Unable to wait for init: $!\n";
	    my $initstatus = $?;
	    $initstatus == 0 or die "git init exited: ".PerforceLink::decode_exitstatus($initstatus)."\n";
	}
	$git_repo = Git->repository(Directory => $git_repo_dir);
    }
    elsif ($opts{d}) {
	die "GIT repo directory must not be given if -o is given\n";
    }

    my $tag_changelists = $opts{t};
    my @branchspecs;
    for (@ARGV) {
	m{([^:]+)(?::([^:]+))?} or die "Invalid branch spec: $_\n";
	my($subdir_pattern, $branch_pattern) = ($1, $2);
	$branch_pattern ||= $subdir_pattern;
	push @branchspecs, [$subdir_pattern, $branch_pattern];
    }

    if ($git_repo) {
	$git_repo->command_noisy("config", "p4-remote.$remotename.base", $p4base);
	$git_repo->command_noisy("config", "p4-remote.$remotename.tag-changelists", $opts{t} ? "true" : "false");
	for my $spec (@branchspecs) {
	    $git_repo->command_noisy("config", "--add", "p4-remote.$remotename.fetch", $spec->[0] eq $spec->[1] ? $spec->[0] : "$spec->[0]:$spec->[1]");
	}
    }

    my($fast_import_pipe, $fast_import_ctx);
    if ($git_repo) {
	($fast_import_pipe, $fast_import_ctx) = $git_repo->command_input_pipe("fast-import", "--quiet");
    }
    else {
	if ($opts{o} eq '-') {
	    $fast_import_pipe = wraphandle(\*STDOUT);
	}
	else {
	    $fast_import_pipe = IO::File->new(">$opts{o}") or die "Can't write $opts{o}: $!\n";
	}
    }

    my %checkpoint_interval = ( bytes => $opts{B}, commits => $opts{C}, time => $opts{T} );
    my $max_changes = $opts{m} || 0;

    my $master_branch;
    my $master_p4base;
    my %high_water_mark;
    if (@branchspecs) {
	for (@branchspecs) {
	    my($subdir_pattern, $branch_pattern) = @$_;

	    my @subdirs = map { $_->{dir} } p4_recv("dirs", "$p4base/$subdir_pattern");
	    if (!@subdirs) {
		warn "No directories matching $subdir_pattern found under $p4base\n";
		next;
	    }

	    for my $p4subpath (@subdirs) {
		my $p4subdir = substr($p4subpath, length($p4base)+1);
		my $branch = convertpath($p4subdir, $subdir_pattern, $branch_pattern);

		validate_p4_base($p4subpath);

		if (!$master_branch) {
		    $master_branch = $branch;
		    $master_p4base = $p4subpath;
		}

		my $last_change = fetch_p4_changes($fast_import_pipe, $p4subpath, undef, $remotename, $branch, $max_changes, \%checkpoint_interval, $tag_changelists);
		$high_water_mark{$branch} = $last_change if ($last_change);
	    }
	}
    }
    else {
	my $last_change = fetch_p4_changes($fast_import_pipe, $p4base, undef, $remotename, "master", $max_changes, \%checkpoint_interval, $tag_changelists);
	$high_water_mark{master} = $last_change if ($last_change);
	$master_branch = 'master';
	$master_p4base = $p4base;
    }

    if ($git_repo) {
	$git_repo->command_close_pipe($fast_import_pipe, $fast_import_ctx);

	while (my($branch, $changeid) = each %high_water_mark) {
	    $git_repo->command("config", "branch.refs/remotes/$remotename/$branch.changelist", $changeid) if ($changeid);
	}

	# Set refs/heads/master to the new branch if it does not already exist, check out the tree if repo is not bare
	if ($git_repo->command("show-ref") !~ m{ refs/heads/master$}) {
	    $git_repo->command_noisy("update-ref", "-m", "$master_p4base imported from Perforce", "refs/heads/master", "refs/remotes/$remotename/$master_branch");
	    $git_repo->command("config", "branch.master.p4-remote", $remotename);
	    $git_repo->command("config", "branch.master.rebase", $master_branch);
	    # This assumes HEAD is master... which is the case if the repo is new
	    if ($git_repo->command_oneline("config", "core.bare") eq 'false') {
		$git_repo->command_noisy("checkout", "-f");
	    }
	}
    }
}
elsif ($subcommand eq 'fetch' || $subcommand eq 'pull') {
    my %opts;
    getopts("o:d:m:nC:B:T:", \%opts) or die "Syntax: $0 fetch [-d git-repo] [-m max-changes] [-C commits-chkpt-interval] [-B bytes-chkpt-interval] [-T time-chkpt-interval]\n";

    my $git_repo_dir = $opts{d};
    my $git_repo = Git->repository(Directory => ($git_repo_dir && abs_path($git_repo_dir)));

    # If pulling, glean the remote name from the branch config if possible
    if (!$globalopts{r} && $subcommand eq 'pull' && $git_repo->command_oneline("config", "core.bare") eq 'false') {
	my $current_branch = get_current_branch($git_repo);
	if ($current_branch) {
	    my $branch_remote = get_config_optional($git_repo, "branch.$current_branch.p4-remote");
	    if ($branch_remote) {
		$remotename = $branch_remote;
	    }
	}
    }

    my $tag_changelists = get_config_optional($git_repo, "p4-remote.$remotename.tag-changelists");
    $tag_changelists = !defined($tag_changelists) ? 1 : $tag_changelists eq 'true';

    my $p4base;
    my @branchspecs;
    if (@ARGV) {
	$p4base = shift;
	for (@ARGV) {
	    m{([^:]+)(?::([^:]+))?} or die "Invalid branch spec: $_\n";
	    my($subdir_pattern, $branch_pattern) = ($1, $2);
	    $branch_pattern ||= $subdir_pattern;
	    push @branchspecs, [$subdir_pattern, $branch_pattern];
	}
    }
    else {
	$p4base = $git_repo->command_oneline("config", "p4-remote.$remotename.base");
	try {
	    for (split(/\n/, $git_repo->command("config", "--get-all", "p4-remote.$remotename.fetch"))) {
		m{([^:]+)(?::([^:]+))?} or die "Invalid branch spec: $_\n";
		my($subdir_pattern, $branch_pattern) = ($1, $2);
		$branch_pattern ||= $subdir_pattern;
		push @branchspecs, [$subdir_pattern, $branch_pattern];
	    }
	} catch Git::Error::Command with {
	};
    }

    my($fast_import_pipe, $fast_import_ctx);
    if ($git_repo) {
	($fast_import_pipe, $fast_import_ctx) = $git_repo->command_input_pipe("fast-import", "--quiet");
    }
    else {
	if ($opts{o} eq '-') {
	    $fast_import_pipe = wraphandle(\*STDOUT);
	}
	else {
	    $fast_import_pipe = IO::File->new(">$opts{o}") or die "Can't write $opts{o}: $!\n";
	}
    }

    my %checkpoint_interval = ( bytes => $opts{B}, commits => $opts{C}, time => $opts{T} );
    my $max_changes = $opts{m} || 0;

    my $master_branch;
    my $master_p4base;
    my %high_water_mark;
    if (@branchspecs) {
	for (@branchspecs) {
	    my($subdir_pattern, $branch_pattern) = @$_;

	    my @subdirs = map { $_->{dir} } p4_recv("dirs", "$p4base/$subdir_pattern");
	    if (!@subdirs) {
		warn "No directories matching $subdir_pattern found under $p4base\n";
		next;
	    }

	    for my $p4subpath (@subdirs) {
		my $p4subdir = substr($p4subpath, length($p4base)+1);
		my $branch = convertpath($p4subdir, $subdir_pattern, $branch_pattern);

		validate_p4_base($p4subpath);

		if (!$master_branch) {
		    $master_branch = $branch;
		    $master_p4base = $p4subpath;
		}

		my $last_change = fetch_last_changelist($git_repo, $remotename, $branch);
		$last_change = fetch_p4_changes($fast_import_pipe, $p4subpath, $last_change, $remotename, $branch, $max_changes, \%checkpoint_interval, $tag_changelists);
		$high_water_mark{$branch} = $last_change;
	    }
	}
    }
    else {
	my $last_change = fetch_last_changelist($git_repo, $remotename, 'master');
	$last_change = fetch_p4_changes($fast_import_pipe, $p4base, $last_change, $remotename, "master", $max_changes, \%checkpoint_interval, $tag_changelists);
	$high_water_mark{master} = $last_change;
	$master_branch = 'master';
	$master_p4base = $p4base;
    }

    $git_repo->command_close_pipe($fast_import_pipe, $fast_import_ctx);

    while (my($branch, $changeid) = each %high_water_mark) {
	$git_repo->command("config", "branch.refs/remotes/$remotename/$branch.changelist", $changeid) if ($changeid);
    }

    if ($subcommand eq 'pull') {
	if ($git_repo->command_oneline("config", "core.bare") eq 'false') {
	    my $current_branch = get_current_branch($git_repo);
	    if (!$current_branch) {
		warn "You don't appear to be on a branch head for merging.\n";
	    }
	    else {
		my $branch_remote = get_config_optional($git_repo, "branch.$current_branch.p4-remote");
		if (!$branch_remote) {
		    warn "Branch '$current_branch' does not have a p4-remote configured\n";
		}
		elsif ($branch_remote ne $remotename) {
		    # Actually, we should decide which remote we are using based on the current branch.
		    warn "Branch '$current_branch' is configured for remote '$branch_remote'\n";
		}
		else {
		    my $rebase_p4branch = get_config_optional($git_repo, "branch.$current_branch.rebase");
		    my $merge_p4branch = get_config_optional($git_repo, "branch.$current_branch.merge");
		    if ($merge_p4branch) {
			$git_repo->command_noisy("merge", "refs/remotes/$remotename/$merge_p4branch");
		    }
		    elsif ($rebase_p4branch) {
			$git_repo->command_noisy("rebase", "refs/remotes/$remotename/$rebase_p4branch");
		    }
		    else {
			warn "Branch '$current_branch' does not have a configuration of which p4 branch to merge or rebase from\n";
		    }
		}
	    }
	}
    }
}
else {
    die "Unknown subcommand: $subcommand\n";
}
